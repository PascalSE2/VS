package server;

import ggtProzess.ggT_ProzessImpl;

import java.util.HashMap;
import java.util.concurrent.LinkedBlockingQueue;

import koordinator.Nachricht;
import koordinator.NachrichtenTyp;
import koordinator.Starter;
import koordinator.ggT_Prozess;

public class CheckTerminierungThread implements Runnable {
    private boolean running;
    private boolean rechter_channel;
    private KoordinatorImpl koordinator_ref;
    private LinkedBlockingQueue<Nachricht> queue = new LinkedBlockingQueue<Nachricht>();


        public CheckTerminierungThread(LinkedBlockingQueue<Nachricht> queue, KoordinatorImpl koordinator_ref, boolean rechter_channel) {
            this.queue = queue;
            this.koordinator_ref = koordinator_ref;
            this.rechter_channel = rechter_channel;
            this.running = true;
        }

        @Override
        public void run() {
            Nachricht msg = null;
            while (running) {

                try {
                    msg = queue.take();
                } catch (InterruptedException e1) {
                    e1.printStackTrace();
                }
                if (running) {
                    ggT_Ref.getSende_lock().lock();
                    this.ggT_Ref.nachrichtAuswerten(msg, this.rechter_channel);
                    ggT_Ref.getSende_lock().unlock();
                }
                
            }
        }

        public void setRunning(boolean running) {
            this.running = running;
            Nachricht dummy_msg = new Nachricht();
            
            if (!running) {
                queue.add(dummy_msg);
            }
        }

}
